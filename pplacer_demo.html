<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>pplacer_demo.sh</title>
    <link rel=stylesheet href="src/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>pplacer_demo.sh</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><p>This is a demonstration for the use of the pplacer suite of programs. It
covers the use of placement, visualization, classification, and comparison.
If you are looking at this file in a web browser after processing with
<a href="http://rtomayko.github.com/shocco/">shocco</a>, the left column will describe
what is going on in the right column.</p>

<p>It is assumed that java is available and that you have installed <code>pplacer</code>
and <code>guppy</code>. See the <a href="https://github.com/fhcrc/microbiome-demo">README</a>
for details.</p>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/bin/bash -eu</span>



</pre></div></td></tr><tr><td class=docs>

<h2>Getting set up (for this demo)</h2>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<p>We start with a couple of little functions to make this script run smoothly.
You can safely ignore them.</p>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<p>For the purposes of this demo, we have a little script function <code>aptx</code> to
run archaeopteryx from within this script (you can also open them directly
from the archaeopteryx user interface if you prefer).</p>

</td><td class=code><div class=highlight><pre>
aptx<span class="o">()</span> <span class="o">{</span>
    java -jar bin/forester.jar -c bin/_aptx_configuration_file <span class="nv">$1</span> 
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>A little <code>pause</code> function to pause between steps.</p>

</td><td class=code><div class=highlight><pre>
pause<span class="o">()</span> <span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">&quot;Please press return to continue...&quot;</span>
  <span class="nb">read</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Make sure that guppy can be found.</p>

</td><td class=code><div class=highlight><pre>
which guppy &gt; /dev/null 2&gt;&amp;1 <span class="o">||</span> <span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">&quot;Couldn&#39;t find guppy. \</span>
<span class="s2">There is a download script in the bin directory for you to use.&quot;</span>
  <span class="nb">exit </span>1
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Echo the commands to the terminal.</p>

</td><td class=code><div class=highlight><pre>
<span class="nb">set</span> -o verbose


</pre></div></td></tr><tr><td class=docs>

<h2>Phylogenetic placement</h2>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<p>This makes p4z1r2.json, which is a "place" file.  Place files contain
information about collections of phylogenetic placements on a tree. You may
notice that one of the arguments to this command is <code>vaginal_16s.refpkg</code>,
which is a "reference package". Reference packages are simply an organized
collection of files including a reference tree, reference alignment, and
taxonomic information. They are optional at this point, but we have found
them to be quite useful. The other arguments include <code>-r</code> which is our
reference alignment, and the anonymous argument, which contains the reads to
be placed.</p>

</td><td class=code><div class=highlight><pre>
<span class="c">#pplacer -c vaginal_16s.refpkg src/p4z1r36.fasta</span>
<span class="c">#pause</span>

</pre></div></td></tr><tr><td class=docs>

<p>We haven't done the alignment in this tutorial, because that would require
another external dependency, but there are scripts which appropriately wrap
HMMER and Infernal in the latest version of pplacer.</p>

</td><td class=code><div class=highlight><pre>


</pre></div></td></tr><tr><td class=docs>

<h2>guppy</h2>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<p><code>guppy</code> is our Swiss army knife for phylogenetic placements.  It has a lot of
different subcommands, which you can learn about with online help by invoking
the <code>--cmds</code> option.</p>

</td><td class=code><div class=highlight><pre>
guppy --cmds
pause


</pre></div></td></tr><tr><td class=docs>

<p>These subcommands are used by writing out the name of the subcommand like</p>

<pre><code>guppy SUBCOMMAND [options] [files]
</code></pre>

<p>For example, we can get help for the <code>fat</code> subcommand.</p>

</td><td class=code><div class=highlight><pre>
guppy fat --help
pause


</pre></div></td></tr><tr><td class=docs>

<h2>Visualization</h2>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<p>Now run <code>guppy fat</code> to make a phyloXML format visualization, and run
archaeopteryx to look at it. Note that fat can be run without the reference
package specification, e.g.:</p>

<pre><code>guppy fat p4z1r36.json
</code></pre>

<p>but in that case there won't be any taxonomic information in the
visualizations.
<a href="http://matsen.fhcrc.org/pplacer/demo/p4z1r36.html">Here</a>
is an online version.</p>

</td><td class=code><div class=highlight><pre>
guppy fat -c vaginal_16s.refpkg p4z1r36.json
aptx p4z1r36.xml &amp;


</pre></div></td></tr><tr><td class=docs>

<h2>Statistical comparison</h2>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<p><code>kr</code> is the command to calculate things using the
<a href="http://arxiv.org/abs/1005.1699">Kantorovich-Rubinstein (KR) metric</a>
which is a generalization of UniFrac. It simply takes in .json files and
spits out numbers. You can run it with the <code>--list-out</code> option to make
tabular output appropriate for R or SQL.</p>

</td><td class=code><div class=highlight><pre>
guppy kr src/*.json
pause

</pre></div></td></tr><tr><td class=docs>

<p>The KR metric can be thought of as the amount of work it takes to move the
distribution of reads from one collection of samples to another along the
edges of the tree. This can be nicely visualized by thickening the branches
of the tree in proportion to the reads which get transported through there.
To get such a visualization, we use guppy's <code>heat</code> subcommand. The
reference package is included again to add in taxonomic annotation.
<a href="http://matsen.fhcrc.org/pplacer/demo/bv.heat.html">Here</a> is a version which
compares all of the vaginosis-positive samples with the negative ones.</p>

</td><td class=code><div class=highlight><pre>
guppy heat -c vaginal_16s.refpkg/ src/p1z1r2.json src/p1z1r34.json &amp;
aptx p1z1r2.p1z1r34.heat.xml

</pre></div></td></tr><tr><td class=docs>

<p><code>guppy</code> can its own variant of hierarchical clustering called squash
clustering. One nice thing about squash clustering is that you can see what
the internal nodes of the clustering tree signify. The clustering is done
with the <code>squash</code> subcommand, which makes a directory containing
<code>cluster.tre</code>, which is the clustering tree, and then a subdirectory
<code>mass_trees</code> which contain all of the mass averages for the internal nodes of
the tree.
<a href="http://matsen.fhcrc.org/pplacer/demo/clusters_0121.html">Here</a>
is a link to a page showing the clustering of all of the samples.</p>

</td><td class=code><div class=highlight><pre>
guppy squash -c vaginal_16s.refpkg -o squash_out src/*.json
aptx squash_out/mass_trees/0006.phy.fat.xml &amp;
aptx squash_out/cluster.tre &amp;

</pre></div></td></tr><tr><td class=docs>

<p><code>guppy</code> does a new kind of principal components analysis (PCA), called "edge
PCA". Edge PCA takes the special structure of phylogenetic placement data
into account. Consequently, it is possible to visualize the principal
component eigenvectors, and it can find consistent differences between
samples which may not be so far apart in the tree. The <code>pca.trans</code> file
contains the samples projected onto principal coordinate axes. 
<a href="http://matsen.fhcrc.org/pplacer/demo/pca.html">Here</a> is the version which
comes from running all of the samples.</p>

</td><td class=code><div class=highlight><pre>
guppy pca -o pca -c vaginal_16s.refpkg src/*.json
cat pca.trans
aptx pca.xml &amp;


</pre></div></td></tr><tr><td class=docs>

<h2>Classification</h2>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<p>Next we run guppy's <code>classify</code> subcommand to classify the reads. The columns
are as follows: read name, attempted rank for classification, actual rank for
classification, taxonomic identifier, and confidence.  We use <code>head</code> here
just to get the first 30 lines so that you can look at them.</p>

</td><td class=code><div class=highlight><pre>
guppy classify -c vaginal_16s.refpkg p4z1r36.json
head -n 30 p4z1r36.class.tab
pause

</pre></div></td></tr><tr><td class=docs>

<p>The rest of the demo requires sqlite3, so we exit if that's not available.</p>

</td><td class=code><div class=highlight><pre>
which sqlite3 &gt; /dev/null 2&gt;&amp;1 <span class="o">||</span> <span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">&quot;No sqlite3, so stopping here.&quot;</span>
  <span class="nb">exit </span>0
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>We can quickly explore the classification results by importing them
into a sql database. First, we create a table containing the tax_ids
and taxonomic names.</p>

</td><td class=code><div class=highlight><pre>
guppy taxtable -c vaginal_16s.refpkg | sqlite3 taxtable.db

</pre></div></td></tr><tr><td class=docs>

<p>Next we insert placement and classification results from multiple
files into our database.</p>

</td><td class=code><div class=highlight><pre>
guppy classify -c vaginal_16s.refpkg --sqlite src/*.json
cat *.sqlite | sqlite3 taxtable.db
sqlite3 -header -column taxtable.db <span class="s2">&quot;select * from placements limit 10&quot;</span>
sqlite3 -header -column taxtable.db <span class="s2">&quot;select * from taxa limit 10&quot;</span>
pause

</pre></div></td></tr><tr><td class=docs>

<p>Now we can use SQL statements to explore the results.</p>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<p>how many sequences per input file?</p>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<p>how many sequences were classified to the species level in each input file?</p>

</td><td class=code><div class=highlight><pre>


</pre></div></td></tr><tr><td class=docs>

<p><code>guppy classify</code> can also emit .sqlite files, which can be run through
<code>sqlite3</code> to build a database of placements, which can be correlated with the
taxonomic data via SQL.</p>

</td><td class=code><div class=highlight><pre>
guppy classify --sqlite -c vaginal_16s.refpkg src/*.json

</pre></div></td></tr><tr><td class=docs>

<p><code>guppy taxtable</code> must first be used to create the schema for the database,
and populate it with the taxonomic data from the reference package.</p>

</td><td class=code><div class=highlight><pre>
guppy taxtable -c vaginal_16s.refpkg | sqlite3 sqlite.db

</pre></div></td></tr><tr><td class=docs>

<p>After that, the .sqlite files can be used to populate the database with the
placements.</p>

</td><td class=code><div class=highlight><pre>
cat *.sqlite | sqlite3 sqlite.db

</pre></div></td></tr><tr><td class=docs>

<p>And at that point, one can write SQL queries against the sqlite3 database.</p>

</td><td class=code><div class=highlight><pre>
sqlite3 -header -column sqlite.db <span class="s2">&quot;</span>
<span class="s2">    SELECT taxa.tax_name,</span>
<span class="s2">           taxa.rank,</span>
<span class="s2">           COUNT(*) AS n_placements</span>
<span class="s2">    FROM   taxa</span>
<span class="s2">           JOIN placements USING (tax_id)</span>
<span class="s2">    GROUP  BY taxa.tax_name,</span>
<span class="s2">              taxa.rank</span>
<span class="s2">    ORDER  BY n_placements</span>
<span class="s2">&quot;</span>
pause


</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
